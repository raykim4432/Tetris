/*
 * TCSS 305: Assignment 6
 */

package file.interaction;

import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.charset.Charset;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import javax.imageio.ImageIO;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;


/**
 * The class holds static methods for reading and writing to files.
 * 
 * @author Ray Kim
 * @version Autumn 2014
 *
 */
public final class FileInteractionHelper {
    
    //constants
    /**
     * Default save and load directory for game files.
     */
    private static final String DEFAULT_SAVE_LOAD_DIRECTORY = "game_files";
    
    /**
     * Contains error message when game file could not be loaded.
     */
    private static final String FAILED_TO_LOAD = "Failed to load game.";
    
    /**
     * File chooser object used for opening and saving files.
     */
    private static final JFileChooser J_FILE_CHOOSER = 
                                    new JFileChooser(DEFAULT_SAVE_LOAD_DIRECTORY);
    
    //constructors and methods
    /**
     * Private constructor for this class.
     */
    private FileInteractionHelper() {
        
    }
    
    //reading text from files
    /**
     * This method reads two ints on a line separated by an "=" and generates an int array.
     * The int values are derived from a text file (whose directory is passed via the 
     * parameter as as a string location).
     * 
     * The first int value [0] is the lines cleared. The second int value [1] is points for
     * clearing the [0] quantity of lines.
     * 
     * @param theDirectory String location of text file which holds score mappings
     * @return List<int[]> int[0] = lines cleared, int[1] = points
     */
    public static List<int[]> generatePointList(final String theDirectory) {
        final List<int[]> resultList = new ArrayList<>();
        
        final Charset charset = Charset.forName("US-ASCII");
        final Path path = FileSystems.getDefault().getPath(theDirectory);
        
        try (BufferedReader reader = Files.newBufferedReader(path, charset)) {
            
            String line = reader.readLine();
            while (line != null) {
                final int[] scoreMapping = new int[2];
                
                //find index of "="
                final int indexOfEquals = line.indexOf('=');
                
                //get int[0]
                final String key = line.substring(0, indexOfEquals - 1).trim();
                scoreMapping[0] = Integer.parseInt(key);
                
                //get int[1]
                final String value = line.substring(indexOfEquals + 1).trim();
                scoreMapping[1] = Integer.parseInt(value);
                
                //add int[] to resultList
                resultList.add(scoreMapping);
                
                line = reader.readLine();
            }
        } catch (final IOException  exception) {
            exception.printStackTrace();
        }
        
        return resultList;
    }
    
    /**
     * This method generates a JLabel HTML string by reading a List of int[]
     * generated by the generatePointList() method (of this class) and generating a string
     * in the format int[0] lines = int[1] points.
     * 
     * 
     * @param theDirectory String location of text file which holds score mappings
     * @return String HTML string
     */
    public static String txtFileToHTML(final String theDirectory) {
        //get score mapping List from theDirectory
        final List<int[]> scoreMappings = generatePointList(theDirectory);
        
        //build string
        final StringBuilder resultHTML  = new StringBuilder(64);
        resultHTML.append("<html>");

        for (final int[] mapping : scoreMappings) {
            resultHTML.append(mapping[0]);
            resultHTML.append(" lines = ");
            resultHTML.append(mapping[1]);
            resultHTML.append(" seconds of silence.<br>");
        }
          
        resultHTML.append("</html>");
        
        return resultHTML.toString();
    } //end of txtFileToHTML
    
    
    //getting images/audio from directories
    /**
     * This method generates a List of buffered images taken from a directory passed 
     * into this method as a parameter. 
     * 
     * Directory mapping code borrowed from:
     * stackoverflow.com/questions/4917326/how-to-iterate-over-the-files-of-a-certain-
     * directory-in-java
     * 
     * Code for building custom FileFilter borrowed from:
     * stackoverflow.com/questions/13517770/jfilechooser-filters
     * 
     * @param theDirectory containing images
     * @return List<BufferedImage> from the given directory
     */
    public static List<BufferedImage> generateBufferedImageList(final String theDirectory) {
        final List<BufferedImage> imageList = new LinkedList<>();
        
        //retrieve all .jpg, .jpeg, .gif, extensioned files in directory
        final File fileDirectory = new File(theDirectory);
        final File[] directoryImageListing = fileDirectory.listFiles(new FileFilter() {
            /**
             * This method checks a file name for the extensions jpeg, png.
             * @param theFile that is being inspected for the appropriate image type extension.
             * @return boolean true if extension is found
             */
            @Override
            public boolean accept(final File theFile) {
                final String nameOfFile = theFile.getName();
                boolean containsExtension = false;
                
                //check for extension
                if (nameOfFile.endsWith(".jpg") || nameOfFile.endsWith(".jpeg") 
                                                || nameOfFile.endsWith(".png")) {
                    containsExtension = true;
                }
                
                return containsExtension;
            }
        });
        
        //iterate through each image file, pull image into BufferedImage and save to List
        if (directoryImageListing != null) {
            
            for (final File imageFile : directoryImageListing) {
                try {
                    //pull image file to bufferedImage, save BufferedImage to List
                    final BufferedImage bufferedImage = ImageIO.read(imageFile);
                    imageList.add(bufferedImage);
                } catch (final IOException exception) {
                    exception.printStackTrace();
                }
            } //end of for
            
        }

        return imageList;
        
    } //end of generateBufferedImageList
    
    /**
     * This method generates a List String audio file directories from a given folder.
     * 
     * @param theDirectory containing the audio files
     * @return List<String> absolute path of audio files
     */
    public static List<String> generateListOfAudioDirectories(final String theDirectory) {
        final List<String> audioDirectoryList = new LinkedList<>();
        
        //retrieve all .mp3, extensioned files in directory
        final File fileDirectory = new File(theDirectory);
        final File[] directoryAudioListing = fileDirectory.listFiles(new FileFilter() {
            /**
             * This method checks a file name for the extension mp3.
             * @param theFile that is being inspected for the appropriate image type extension.
             * @return boolean true if extension is found
             */
            @Override
            public boolean accept(final File theFile) {
                final String nameOfFile = theFile.getName();
                boolean containsExtension = false;
                
                //check for extension
                if (nameOfFile.endsWith(".mp3")) {
                    containsExtension = true;
                }
                
                return containsExtension;
            }
        });
        
        //convert File[] directoryAudioListing to a List containing audio file names
        if (directoryAudioListing != null) {
            
            for (final File audioFile : directoryAudioListing) {
                final String uri = audioFile.toURI().toString();
                audioDirectoryList.add(uri);
            } //end of for
            
        }

        return audioDirectoryList;
        
    } //end of generateListOfAudioDirectories
    
    
    
    //game file save and load methods
    /**
     * Method for saving game files. Uses serializable class that contains game
     * state data. This serializable class is serialized and saved to a default
     * game data save/load directory.
     * 
     * Code for saving and loading serializable borrowed from:
     * youtube.com/watch?v=YzwiuRdgSSy
     * 
     * @param theData that will be saved
     * @return boolean true if save is successful, false if it is not
     */
    public static boolean saveGameData(final TetrisGameData theData) {
        boolean fileSaveSuccessful = false;
        
        //open save dialogue box
        final int returnVal = J_FILE_CHOOSER.showSaveDialog(null);
        
        if (returnVal == JFileChooser.APPROVE_OPTION) {
          //save file using PixelImage's save method
            try {
                //create new file output stream based on the user selected save destination
                final FileOutputStream fileOutStream = new FileOutputStream(J_FILE_CHOOSER.
                                                                      getSelectedFile());
                final ObjectOutputStream objectOutStream = new 
                                                ObjectOutputStream(fileOutStream);
                
                //write object
                objectOutStream.writeObject(theData);
                
                objectOutStream.close();
                
                fileSaveSuccessful = true;
                
            } catch (final IOException exception) {
                JOptionPane.showMessageDialog(null, "Could not save game.");
                exception.printStackTrace();
            } 
        }
        
        
        return fileSaveSuccessful;
        
    } //end of saveGameData
    
    
    /**
     * Method for loading saved game files. Uses JFileChooser to load saved game.
     * 
     * Code for saving and loading serializable borrowed from:
     * youtube.com/watch?v=YzwiuRdgSSy
     * 
     * @return TetrisGameData containing saved game state.
     */
    public static TetrisGameData loadGameData() {
        TetrisGameData gameData = null;
        
        //open load dialogue box
        final int returnVal = J_FILE_CHOOSER.showOpenDialog(null);
        
        //if a file is selected(user does not hit cancel)
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            try {
                
                //create new file input stream object
                final FileInputStream fileInStream = new 
                                                FileInputStream(J_FILE_CHOOSER.
                                                                getSelectedFile()); 
                
                //create object input stream
                final ObjectInputStream objectInStream = 
                                                new ObjectInputStream(fileInStream);
                
                //get object from object input stream
                gameData = (TetrisGameData) objectInStream.readObject();
                
                objectInStream.close();
                    
            } catch (final IOException exception) {
                JOptionPane.showMessageDialog(null, FAILED_TO_LOAD);
                exception.printStackTrace();
                
            } catch (final ClassNotFoundException exception) {
                JOptionPane.showMessageDialog(null, FAILED_TO_LOAD);
                exception.printStackTrace();
                
            } //end of try catch
            
        }
        
        return gameData;
    } //end of loadGameData
    
}
